\documentclass[handout]{beamer}

\usetheme{default}
\usecolortheme{beaver}

\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amssymb,latexsym}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}
\usepackage{alltt}
\usepackage[ruled,vlined]{algorithm2e}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\title{Introducción a la Programación Funcional\\Módulo 0\\Unidad 1. Lenguajes, paradigmas y programación funcional}
\date{6 de Octubre de 2020}
\author{S4N Campus\\Juan Francisco Cardona M}
\institute{Seven4N}

\begin{document}

\begin{frame}
  \titlepage{}
\end{frame}

\begin{frame}
  \frametitle{Agenda}\tableofcontents
\end{frame}

% Tomado del libro de Maribel Fernández
% Programming Languages and Operational Semantics. A Concise Overview
% Chapter 01.

\section{Módulo 0.\\Unidad 1. Lenguajes, paradigmas y programación funcional}

\subsection{Objetivos}

\begin{frame}
  \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
  \framesubtitle{Objetivos}

  Al finalizar esta unidad:
  \begin{itemize}
  \item<1-> Definirás qué son los lenguajes de programación
  \item<2-> Identificarás cuáles son los modelos de computador
  \item<4-> Identificarás cuáles son los paradigmas de programación (en alto nivel)
  \end{itemize}
\end{frame}

\subsection{¿Qué son los lenguajes de programación?}

\begin{frame}
  \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
  \framesubtitle{¿Qué son los lenguajes de programación?}
  \begin{block}{Definición de los lenguajes de programación}
    \begin{itemize}
    \item<2-> No hay una definición formal
    \item<3-> Un posible acercamiento:
      \begin{itemize}
      \item<4-> Permiten indicarle de forma no ambigua cómo deben
        \emph{computar} y \emph{transformar} los datos el computador
      \item<5-> Comunicar con el computador y los programadores
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
  \framesubtitle{¿Qué son los lenguajes de programación?}
  \begin{block}{Definición de los lenguajes de programación}
    \begin{itemize}
    \item<2-> Entonces: \alert{¿Qué lo define?}
      \begin{itemize}
      \item<3-> Gramática,
      \item<3-> Semántica,
      \item<3-> Pragmática.
      \end{itemize}
    \item<4-> La forma de razonar de cómo escribir un programa:
      \alert{Modelo de computador} y \alert{Paradigmas de
        programación}.
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Modelo de computador y lenguajes de programación}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{Modelo de computador y lenguajes de programación}

  \begin{multicols*}{3}
    \pause
    \includegraphics[width=2.2cm,height=5cm]{../../../../imagenes/ModeloComputador}
    \pause
    \includegraphics[width=2.2cm,height=5cm]{../../../../imagenes/ModeloComputadorC++}
    \pause
    \includegraphics[width=2.5cm,height=6cm]{../../../../imagenes/ModeloComputadorRealC++Dilema}
  \end{multicols*}

\end{frame}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{Modelo de computador y lenguajes de programación}

  \begin{multicols}{2}
    \pause
    \includegraphics[width=5cm,height=6cm]{../../../../imagenes/ModeloComputadorRealC++Compilado}
    \pause
    \includegraphics[width=5cm,height=6cm]{../../../../imagenes/ModeloComputadorRealC++Interpretado}
  \end{multicols}

\end{frame}

\subsection{Paradigmas de programación}

\begin{frame}
  \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
  \framesubtitle{Paradigmas de programación}
  \begin{itemize}[<+->]
  \item Un lenguaje de programación induce:
    \begin{itemize}
    \item un estilo particular de programación,
    \item un conjunto particular de métodos y técnicas para razonar sobre los programas.
    \end{itemize}
  \item \alert{Paradigma de programación}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
  \framesubtitle{Paradigmas de programación}
  \begin{itemize}[<+->]
  \item Los lenguajes de programación son clasificados de
    acuerdo al paradigma que ellos soportan:
    \begin{itemize}
    \item<1-> Imperativo \alert<3->{(¿Cómo?)}
    \item<2-> Declarativo \alert<4->{(¿Qué?)}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsubsection{Lenguajes imperativos}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{Paradigmas de programación - Lenguajes imperativos}
  \begin{itemize}
  \item<1-> El modelo es el computador físico
  \item<2-> Se consulta y modifica variables en memoria
  \item<3-> Se ejecuta una instrucción tras otra
  \item<4-> Los ciclos y condiciones cambian la secuencia de ejecución
  \item<5-> Las funciones y procedimientos son formas de valores e instrucciones
  \item<6-> Los datos son agrupados en registros o estructuras
  \item<7-> Los módulos agrupan datos y procedimientos de forma lógica
  \end{itemize}
\end{frame}


% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Paradigmas de programación - Lenguajes imperativos}
%   \begin{itemize}
%   \item<1-> Los programas son descompuestos dentro
%     de \emph{pasos de computación} (comandos, instrucciones y
%     órdenes) que reflejan la ejecución paso a paso
%     en el hardware del computador.
%   \item<2-> Los subprogramas (rutinas, procedimientos) son utilizados
%     para construir los programas en un modo modular.
%   \item<3-> Programas escritos en lenguajes imperativos dan precisas
%     descripciones de \emph{cómo} resolver un problema determinado.
%   \item<4-> Ejemplos de lenguajes:
%     \begin{itemize}
%     \item Fortran
%     \item Algol
%     \item Pascal
%     \item C
%     \item Python
%     \item Java
%     \end{itemize}
%   \end{itemize}
% \end{frame}

% \subsubsection{Lenguajes orientados a objeto}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Paradigmas de programación - Lenguajes orientados a objeto}

%   \begin{itemize}[<+->]
%   \item Los programas son colecciones de objetos los cuales pueden ser
%     accedidos únicamente a través de operaciones (o métodos)
%     suministrados por ellos, y están usualmente organizados en
%     jerarquías.
%   \item Un objeto puede ser visto como una entidad que combina datos
%     (campos) y operaciones (métodos).
%   \item En la metodología de diseño orientada a objetos, el diseñador
%     produce una descripción jerarquica de la estructura de un sistema,
%     el cual es la base para la implementación en un lenguaje orientado
%     a objeto.
%   \item La orientación a objeto es considerada una característica de los
%     lenguajes imperativos, sin embargo también puede ser encontrada
%     en lenguajes funcionales y combinada con lenguajes lógicos.
%   \end{itemize}
% \end{frame}

\subsubsection{Lenguajes declarativos}


\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{Paradigmas de programación - Lenguajes imperativos}

  \begin{itemize}
  \item<1-> Su modelo de computación son modelos matemáticos
  \item<2-> La variable se liga a un valor, no a una posición de memoria
  \item<3-> Un programa es:
    \begin{itemize}
    \item<4-> una expresión, o
    \item<5-> un conjunto de hechos o reglas que relacionan hechos
    \end{itemize}
  \item<5-> No hay diferencia entre programas y datos
  \item<6-> Dos subgrupos:
    \begin{itemize}
    \item<7-> Programación funcional
    \item<8-> Programación lógica
    \end{itemize}
  \end{itemize}
\end{frame}

\subsubsection{¿Qué es la programación funcional?}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{¿Qué es la programación funcional?}

  \begin{quote}
    Según (\cite{turtle-2020}): ``La programación funcional es el acto
    de escribir programas con \emph{funciones puras}. Las funciones
    puras tiene tres propiedades:
    \begin{itemize}
    \item<2-> \textbf{Total:} retorna un valor por cada posible entrada
    \item<3-> \textbf{Determinista:} retorna el mismo valor por la misma entrada
    \item<4-> \textbf{Inculpable:} no iteración (\emph{directa}) con el mundo o el estado del programa''
    \end{itemize}
  \end{quote}
\end{frame}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{¿Qué es la programación funcional?}

  \begin{quote}
    Según (\cite{chisano-2015}): ``La programación funcional (PF) está
    basada en la simple premisa con implicaciones de largo alcance:
    nosotros construimos los programas utilizando únicamente \emph{funciones puras}, en otras palabras,
    funciones que no tiene \emph{efectos colaterales}''
  \end{quote}
\end{frame}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \begin{block}{¿Qué significa sin efectos colaterales?}
    \begin{itemize}
    \item<1-> Datos inmutables
    \item<2-> Sin operaciones de entrada y salida
    \item<3-> Sin rompimientos de control (Sin excepciones)
    \end{itemize}
  \end{block}
\end{frame}
% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Paradigmas de programación - Lenguajes funcionales}
%   \begin{itemize}
%   \item<1-> Programas son funciones, las cuales pueden ser
%     compuestas para construir nuevas funciones como
%     en la teoría de funciones.
%   \item<2-> Esta clase de lenguajes son llamados también declarativos,
%     desde que su enfoque es \emph{qué} debe computado y no \emph{cómo}
%     debe ser computado.
%   \item<3-> Los lenguajes funcionales enfatizan el uso de expresiones,
%     las cuales son evaluadas por simplificación.
%   \item<4-> Ejemplos:
%     \begin{itemize}
%     \item Haskell
%     \item SML
%     \item Caml
%     \item Clean
%     \item Scala
%     \end{itemize}
%   \end{itemize}
% \end{frame}

% \subsubsection{Lenguajes lógicos}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Paradigmas de programación - Lenguajes lógicos}

%   \begin{itemize}[<+->]
%   \item Programas describen un problema en vez de definir una
%     implementación algoritmica.
%   \item Esta clase de lenguajes es considerada declarativa, desde
%     que el foco es la especificación del problema que necesita
%     ser resuelta y no \emph{cómo} ésta es resuelta.
%   \item Un programa lógico es una descripción (usualmente utilizando
%     un lenguaje de lógica de primer orden) de hechos y propiedades
%     sobre el problema.
%   \item Los lenguajes lógicos combinan lógica y resolución de restricciones.
%   \end{itemize}
% \end{frame}

% \subsection{Componentes de un lenguaje de programación}

% \begin{frame}
%   \frametitle{Componentes de un lenguaje de programación}
%   \begin{itemize}[<+->]
%   \item Un lenguaje de programación tiene tres componentes principales:
%     sintaxis, semántica e implementación.
%     \begin{enumerate}
%     \item \textbf{\emph{Sintaxis}}: define la forma de los
%       programas. Este describe la forma en que las expresiones,
%       instrucciones y declaraciones son puestas juntas para formar un
%       programa.
%     \item \textbf{\emph{Semántica}}: da el significado de los
%       programas. Este describe la forma que los programas se comportan
%       cuando son ejecutados.
%     \item \textbf{\emph{Implementación}}: un sistema de software puede
%       leer un programa y ejecutarlo en un computador. (Compiladores,
%       editores, depuradores).
%     \end{enumerate}
%   \end{itemize}
% \end{frase}

% \subsubsection{Arquitectura del computador}

% \begin{frame}
%   \frametitle{Componentes de un lenguaje de programación}
%   \framesubtitle{Arquitectura del computador}

%   \begin{itemize}[<+->]
%   \item Los componentes principales de una máquina \emph{Von Neumann}:
%     \begin{itemize}
%     \item Memoria
%     \item Procesador
%     \item Perifericos
%     \item Sistema de ficheros
%     \end{itemize}
%   \item El conjunto de instrucciones para aritmetica y operaciones
%     son usualmente llamadas \emph{lenguaje de máquina}.
%   \item El sistema operativos suministra primitivas de alto nivel.
%   \item Implementaciones de lenguajes son construidos encima de los OS.
%   \item Y sobre los lenguajes los programas de usuario.
%   \end{itemize}
% \end{frame}

% \subsubsection{Implementación del lenguaje}

% \begin{frame}
%   \frametitle{Componentes de un lenguaje de programación}
%   \framesubtitle{Implementación del lenguaje}
%   \begin{itemize}[<+->]
%   \item Los lenguajes de programación pueden ser clasificados
%     de bajo o alto nivel, dependiendo de cual cercanos son a una
%     máquina en particular.
%   \item Los lenguajes de alto nivel pueden ser implementados por:
%     \begin{itemize}
%     \item Compilación
%     \item Interpretación
%     \item Un método hibrido
%     \end{itemize}
%   \end{itemize}
% \end{frame}

% \subsection{Origenes históricos de la programación funcional}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Origenes históricos}

%   \begin{itemize}[<+->]
%   \item Los lenguajes funcionales e imperativos crecieron del trabajo por
%     matemáticos como: Alan Turing, Alonzo Church, Stephen Kleene, Emil Post y
%     otros en los años 30.
%   \item Trabajando independientemente desarrollaron:
%     \begin{itemize}
%     \item La noción de formalización de algoritmo (o \emph{procedimiento efectivo})
%     \item Manipulación símbolica
%     \item Funciones recursivas
%     \item Combinatorias.
%     \end{itemize}
%   \item Todas esas formalizaciones fueron mostradas que tenían la misma potencia.
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Origenes históricos}
%   \begin{itemize}[<+->]
%   \item El anterior resultado conduce a Church a conjeturar:
%     \begin{quote}
%       $\dots$
%       qué \emph{cuálquier} modelo de computación atractivo debe ser
%       igualmente poderoso también.
%     \end{quote}
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Origenes históricos}
%   \begin{itemize}[<+->]
%   \item El modelo de computación de Turing es la \emph{máquina de
%       Turing}.
%   \item La máquina de Turing es una autómata que recuerda los
%     autómatas de estado finito, pero con la habilidad de acceder
%     celdas.
%   \item El modelo de Church de computación es llamado \emph{cálculo
%       lambda}.
%   \item Este es basado en la noción de expresiones parametrizadas (con
%     cada parámetro introduccido por la ocurrencia de la letra
%     $\lambda$).
%   \item El cálculo lambda fue la inspiración para la programación funcional:
%     por medio de la sustitución de paramétros dentro de las expresiones, como
%     cuando se computa en un lenguaje de alto-nivel.
%   \item Los modelos de computación de Kleene y Post son más
%     abstractos, y no llevan ellos mismos a la implementación como un
%     lenguaje de programación.
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Origenes históricos}
%   \begin{itemize}[<+->]
%   \item El objetivo de cada trabajo de computabilidad no fue entender
%     computadores pero formalizar la noción de un procedimiento efectivo.
%   \item Estos trabajos permitieron a los matemáticos formalizar la
%     distición entre un \emph{prueba constructiva} de una \emph{prueba
%       no-constructiva}.
%   \item \textbf{Prueba constructiva:} una prueba que meramente muestra
%     como obtener un objeto matemático con una propiedad determinada.
%   \item \textbf{Prueba no-constructiva:} una prueba que meramente
%     muestra que un objeto debe existir, talvez por contradicción, o
%     contando argumentos, o la reducción de algún otro teorema cuya prueba
%     es no-constructiva.
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Origenes históricos}

%   \begin{quote}
%     Un programa puede ser visto como una prueba constructiva de la
%     proposición que, dada las entradas apropiadas, existe allí una
%     salida que está relacionada con las entradas en una particular
%     forma deseada.
%   \end{quote}
% \end{frame}

% \subsection{Conceptos de programación funcional}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}

%   \begin{itemize}
%   \item<1-> \textbf{Programación funcional:} define la salida de un programa
%     como una función matemática de las entradas, sin noción de estado
%     interno y así sin efectos colaterales.
%   \item<2-> Para hacer la programación funcional práctica, los lenguajes
%     funcionales suministran un número de características que se
%     omiten frecuentemente en los lenguajes imperativos:
%     \begin{itemize}
%     \item<3-> Está basado en el modelo de cálculo lambda.
%     \item<3-> Valores de funciones de primera clase y funciones de alto-orden.
%     \item<3-> Polimorfismo extensivo.
%     \item<3-> Tipos de listas y operadores.
%     \item<3-> Returnas funciones estructuradas.
%     \item<3-> Constructores (agregados) para objetos estructurados.
%     \item<3-> Recolectores de basura.
%     \end{itemize}
%   \end{itemize}
% \end{frame}

% \subsubsection{Cálculo lambda}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}
%   \begin{block}{Cálculo lambda}
%     \begin{itemize}
%     \item<1-> Es un modelo para:
%       \begin{itemize}
%       \item<2-> Definir funciones matemáticas,
%       \item<3-> Aplicar dichas funciones.
%       \end{itemize}
%     \item<4-> \alert{Tesis Turing-Church}
%     \item<5-> Se tiene un modelo válido para definir la programación.
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsubsection{Valores de funciones de primera-clase y funciones de alto-orden}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}
%   \begin{block}{Valores de funciones de primera-clase y funciones de alto-orden}
%     \begin{itemize}[<+->]
%     \item Se define un valor de primera-clase como uno que puede
%       ser pasado como un paramétro, retornado de una sub-rutina,
%       o (en un lenguaje con \emph{side-effects}) asignaciones a una variable.
%     \item Un estado de primera-clase también requiere la habilidad
%       para crear (computar) nuevos valores en tiempo de ejecución.
%     \item En el caso de sub-rutinas, esta noción de primera-clase require
%       una expresión lambda que pueda capturar valores dentro de un
%       espacio definido.
%     \item Una función de alto-orden toma una función como argumento,
%       o retorna una función como argumento.
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsubsection{Polimorfimos extensivo}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}

%   \begin{block}{Polimorfismo extensivo}
%     \begin{itemize}[<+->]
%     \item Polimorfismo permite que una función pueda ser utilizada como
%       una clase general de argumento como sea posible.
%     \item El polimorfismo puede ser dinámico (LISP) o estático (ML,
%       Haskell).
%     \item Algunos lenguajes utilizan polimorfismo a través de la
%       inferencia de tipos (ML, Haskell).
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsubsection{Tipo listas}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}

%   \begin{block}{Tipos listas}
%     \begin{itemize}[<+->]
%     \item Listas son definidas de manera recursiva.
%     \item Listas son manipuladas a través de un mecanismo
%       de coincidencia de patrones: el inicio de la lista y el resto
%       de la lista.
%     \item La recursión es el único mecanismo que permite hacer
%       o construir cosas repetidamente.
%     \item Una función n-binaria ($n > 1$) puede ser utilizada
%       como un operador.
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsubsection{Constructores (agregados) para objetos estructurados}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}

%   \begin{block}{Constructores (agregados) para objetos estructurados}
%     \begin{itemize}[<+->]
%     \item Los lenguajes pueden especificar valores literales de tipos
%       de datos compuestos (arreglos, estructuras, listas).
%     \item Los literales compuestos son llamados agregados.
%     \item Un lenguaje funcional puro debe suminitrar agregados
%       generales: debido a que no hay forma de actualizarlos
%       deben ser inicializados de una.
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsubsection{Recolectores de basura}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Conceptos de programación funcional}

%   \begin{block}{Recolectores de basura}
%     \begin{itemize}[<+->]
%     \item Los recolectores de basura no son universalmente utilizados
%       en los lenguajes imperativos, pero los en los lenguajes funcionales.
%     \item Los lenguajes funcionales tiene a emplear el montículo
%       (\emph{heap}) para todos los datos dinámicos.
%     \item El recolector de basura es utilizado para eliminar todos los
%       valores de primera-clase.
%     \end{itemize}
%   \end{block}
% \end{frame}

% \subsection{¿Qué es la programación funcional?}
% \label{sec:que-es-la-programacion-fp}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{¿Qué es la programación funcional?}

%   \begin{enumerate}
%   \item<1-> Programación funcional es sobre escribir software únicamente con funciones puras.
%   \item<2-> Cuándo usted escribe código funcional, usted únicamente utiliza valores inmutables. .
%   \end{enumerate}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{¿Qué es la programación funcional?}

%   \begin{quote}
%     La programación funcional es una forma de escribir software utilizando únicamente funciones puras y valores
%     inmutables.
%   \end{quote}
% \end{frame}

% \subsection{¿Qué es una función pura?}
% \label{sec:que-es-una-funcion-pura}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{¿Qué es una función pura?}

%   \begin{itemize}
%   \item<1-> La salida de una función pura depende únicamente de sus valores de entrada y su algoritmo interno.
%   \item<2-> Una función pura no tiene efectos colaterales.
%   \end{itemize}
% \end{frame}

% \subsection{¿Qué son valores inmutables?}
% \label{sec:valores-inmutables}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{¿Qué son valores inmutables?}

%   \begin{itemize}
%   \item<1-> En los lenguajes imperativos los valores pueden cambiar.
%   \item<2-> En los lenguajes declarativos los valores no pueden cambiar.
%   \item<3-> Los valores se transforma, a partir de un valor se crea un valor nuevo.
%   \end{itemize}

% \end{frame}

% \subsection{Scala como un lenguaje funcional}
% \label{sec:scala}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Scala como un lenguaje funcional}

%   \begin{itemize}
%   \item<1-> Scala es un lenguaje de propósito general,
%   \item<2-> que soporta la programación orientada a objetos,
%   \item<3-> que soporta la programación funcional.
%   \item<4-> Con un sistema de tipos fuertemente tipeado.
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Scala como un lenguaje funcional}

%   \begin{itemize}
%   \item<1-> Vamos a utilizar la parte funcional de Scala.
%   \item<2-> Nos permite un acercamiento más puro a la programación funcional.
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Scala como un lenguaje funcional}

%   \begin{itemize}
%   \item<1-> En \href{https://sdkman.io/}{sdkman} es una herramienta que permite manejar varios ambientes de desarrollo basados en Java.
%     \begin{enumerate}
%     \item<2-> Instale \href{https://sdkman.io/}{sdkman}
% \begin{alltt}
% \$ curl -s "https://get.sdkman.io" | bash
% \end{alltt}
%     \item<3-> Ahora instale Scala
% \begin{alltt}
% \$ sdk install scala
% \end{alltt}
% \item<4-> Ahora instale sbt
% \begin{alltt}
% \$ sdk install sbt
% \end{alltt}
%    \end{enumerate}
%   \end{itemize}
% \end{frame}

% \subsection{Definición de funciones}
% \label{sec:def-funciones}

% \begin{frame}[fragile]
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Definición de funciones}
%    \begin{itemize}
%    \item<1-> Scala nos permite definir valores inmutables \texttt{val}
% % \begin{lstlisting}[language=Haskell]
% % f (x,y) = (x, ['a' .. y])
% % \end{lstlisting}
% \begin{lstlisting}[language=Scala]
% val diez = 10
% \end{lstlisting}
% \item<2-> Scala nos permite definir funciones. Definamos una
%   función que calcule el mínimo de dos valores enteros.
% \begin{lstlisting}[language=Scala]
% def minimo(x:Int, y:Int):Int = if (x<=y) x else y
% \end{lstlisting}
%    \end{itemize}
%  \end{frame}


%  \begin{frame}
%   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
%   \framesubtitle{Definición de funciones}

%   \begin{exampleblock}{Definición de signo}
%     Defina una función \texttt{signo} que evalue la siguiente definición:
%     \[
%       signo(x) = \begin{cases}
%         x < 0 & -1 \\
%         x = 0 & 0 \\
%         x > 0 & 1 \\
%         \end{cases}
%     \]
%   \end{exampleblock}
% \end{frame}

% % \subsection{Definición de tipos algebraicos}
% % \label{sec:valores-inmutables}

% % \begin{frame}
% %   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
% %   \framesubtitle{Definición de tipos algebraicos}

% %   \begin{exampleblock}{Definición de sucesor}
% %     Los valores númericos se pueden definir de una forma
% %     matemática:

% %     \[
% %       Numero = \begin{cases}
% %         0 & \\
% %         Succ(Numero) &  \\
% %         \end{cases}
% %     \]
% %   \end{exampleblock}
% % \end{frame}

% % \begin{frame}[fragile]
% %   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
% %   \framesubtitle{Definición de tipos algebraicos}

% %   \begin{block}{Definición de un valor algebraico}
% % \begin{lstlisting}[language=Scala]
% % sealed trait Number
% % case object Zero extends Number
% % case class Succ(x:Number) extends Number
% % \end{lstlisting}
% %   \end{block}
% % \end{frame}

% % \begin{frame}[fragile]
% %   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
% %   \framesubtitle{Definición de tipos algebraicos}

% %   \begin{exampleblock}{Definición}
% % \begin{lstlisting}[language=Scala]
% % def isZero(x:Number):Boolean = x match {
% %   case Zero => true
% %   case _    => false
% % }
% % \end{lstlisting}
% %   \end{exampleblock}
% % \end{frame}

% % \begin{frame}
% %   \frametitle{Unidad 1. Lenguajes, paradigmas y programación funcional}
% %   \framesubtitle{Definición de tipos algebraicos}

% %   \begin{enumerate}
% %   \item Defina una función (\texttt{sum}) se sume dos números.
% %   \item Defina una función (\texttt{mult}) que multiplique dos
% %     números.
% %   \end{enumerate}

% % \end{frame}

\subsection{Bibliografía}

\bibliographystyle{alpha}

\begin{frame}
  \frametitle{Unidad 1. Paradigmas de programación y programación
    funcional}
  \framesubtitle{Bibliografía}

  \bibliography{S4N-PFScala-2020-2-m00-u01}
\end{frame}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
